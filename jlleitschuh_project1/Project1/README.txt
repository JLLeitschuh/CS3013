Phase 1 was fairly trivial, though there was a bit of confusion as using manuals took a bit of practice getting used to. Knowing what to pass in to execvp() also took a while, though in the end that was the hardest part of Phase 1. It seems as though execvp() does not have the capability to parse multiple commands together, such as /*sleep 5 && echo helloworld*/. In Phase 3 of the project, you will see that such functionality has, to a certain extent, been accounted for in the program.

Phase 2 was a bit more challenging, yet still quite enjoyable in its own right. Buffers had to be used to store incoming data for later sections in the code (partitioning out a section of memory is ok here, as the buffer will always be used). All the code was made to run in an infinite loop, exiting out either at the end of a file piped in as input,  or when "exit" was input.

Phase 3 was the most difficult phase, as new data structures had to be implemented, and there could be no ambiguity in the flow of the program. Most difficult was testing for "out of order commands". To attempt to test for this, testing a series of /*sleep 5 && echo helloworld*/ were done. This did not turn out well as it appears that execvp() does not parse special string tokens such as && by default, if at all. To accomodate special strings such as &&, the program had to be refactored, and even then, is only able to process /*sleep 5 && echo helloworld*/ as two distinct processes, instead of a single one as the default Linux Terminal does. Many functions were written to reduce redundant code, and the struct, process, was created to store necessary information. An on-going tally of ongoing background processes was stored in a linked list, which seemed to be the most appropriate method of doing so. By storing a log of alive children processes, information on the process, such as when it was initiated, is easily accessible. Modifying this linked list is also fairly easy, so logged processes may be removed rather easily when they have died. One other thing to note is that giving an input of \t (tab) produces an "invalid argument(s)" error. Adding this to the delimiter would have been a simple task, but as tabs have a unique function in the default Linux Terminal, it was decided that the results produced were fine.
